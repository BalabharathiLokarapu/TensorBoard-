<!--
@license
Copyright 2018 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../iron-pages/iron-pages.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../paper-slider/paper-slider.html">
<link rel="import" href="../paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../paper-tabs/paper-tab.html">
<link rel="import" href="../paper-tabs/paper-tabs.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../tf-backend/tf-backend.html">
<link rel="import" href="../tf-dashboard-common/dashboard-style.html">
<link rel="import" href="../tf-dashboard-common/tf-dashboard-layout.html">
<link rel="import" href="../tf-dashboard-common/tf-option-selector.html">
<link rel="import" href="../tf-imports/closure.html">
<link rel="import" href="../tf-inference-panel/tf-inference-panel.html">
<link rel="import" href="../tf-storage/tf-storage.html">
<link rel="import" href="../tf-tensorboard/registry.html">
<link rel="import" href="../vz-example-viewer/vz-example-viewer.html">
<link rel="import" href="../vz-line-chart/vz-line-chart.html">
<link rel="import" href="../facets-dive/components/facets-dive/facets-dive.html">
<link rel="import" href="./tf-confusion-matrix.html">
<link rel="import" href="./tf-inference-viewer.html">

<!--
  A frontend that displays a set of editable examples and enables inference of those examples,
  visualizing the results.
-->
<dom-module id="tf-interactive-inference-dashboard">
  <template>
    <style id="linter-paper-button-style">
      /**
       * This style preserves the styling previous to
       * https://github.com/PolymerElements/paper-button/pull/115
       * This change can break the layout of paper-button content.
       * Remove this style to apply the change, more details at b/70528356.
       */
      paper-button {
        display: inline-block;
        text-align: center;
        font-family: inherit;
      }
    </style>
    <style>
      #classification {
        width: 40%;
      }

      .example-holder {
        max-height: calc(100% - 20px);
        width: 100%;
      }

      .inference-holder {
        max-height: 35%;
        overflow: auto;
      }

      .tf-option-selector-0 .content-wrapper.tf-option-selector  > * {
        width: 40%;
      }

      #spinner {
        position: absolute;
        top: 95px;
        left: 250px;
        width: 14px;
        height: 14px;
        --paper-spinner-color: var(--tb-orange-strong);
      }

      .noexamples {
        position: absolute;
        top: 75px;
        left: 280px;
      }

      .center {
        position: relative;
      }

      .info-text {
        font-size: 12px;
        color: #777;
        margin: 20px 0px;
      }

      .button {
        font-size: 13px;
        margin: 10px 0 0 0;
        background-color: #757575;
        color: white;
      }

      .button[disabled] {
        background-color: #ccc;
      }

      .input-and-tooltip {
        display: flex;
      }

      .label-vocab-path-input {
        flex-grow: 1;
      }

      .help-icon {
        width: 15px;
        padding: 0px;
        color: #757575;
      }

      .tooltip {
        width: 300px;
      }

      .threshold-dropdown {
        display: block;
      }

      .slider-label {
        --paper-input-container-underline: {
          display: none;
        };
      }

      .slider {
        margin-top: -30px;
        width: 100%;
        --paper-slider-input: {
          width: 80px;
        }
      }

      .pr-line-chart {
        height: 150px;
        width: 250px;
        display: inline-block;
      }

      .inference-settings {
        padding: 20px;
        width: 75%;
      }

      .dashboard-layout {
        display: flex;
        height: 100%;
      }

      .center {
        width: 80%;
      }

      .side-holder {
        height: 100%;
        width: 20%;
        display: flex;
        flex-direction: column;
      }

      .side-content {
        height: 80%;
        flex: 1 0 auto;
      }

      .bottom-side {
        flex-shrink: 0;
      }

      .side-tabs {
        display: flex;
        height: calc(100% - 40px);
      }

      .datapoint-tab {
        width: 100%;
        display: flex;
        flex-direction: column;
      }

      .config-tab {
        width: 100%;
        overflow: auto;
      }

      .inference-header {
        font-size: 20px;
      }

      .conf-matrix {
        margin-left: 20px;
      }

      /* Hide the Facets Dive info card and keep the background consistent with TensorBoard. */
      ::content #dive #infoCard {
        background: #f5f5f5;
      }
      ::content #dive #infoCard > div {
        display: none;
      }

      ::content #dive #infoCard {
        width: 0px;
      }
    </style>
    <paper-dialog id="inferencesettings" class="inference-settings" opened="true" with-backdrop>
        <div class="info-text">
            <p>
              Load tf.Example protos and visualize them with
              <a href="https://github.com/pair-code/facets" target="_blank">Facets Dive</a>.
              Select examples then edit them below with the example viewer.
            </p>
            <p>
              Perform inference on the examples through
              <a href="https://github.com/tensorflow/serving" target="_blank">TensorFlow Serving</a>
              and see the inference results.
              After inference is run, Facets Dive will color each example by its inference result.
            </p>
            <p>
              See <a target="_blank" href="https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins/interactive_inference/README.md">documentation</a>
              for usage instructions.
            </p>
          </div>

        <tf-inference-panel inference-address="{{inferenceAddress}}"
                          model-name="{{modelName}}"
                          examples-path="{{examplesPath}}"
                          model-type="{{modelType}}"></tf-inference-panel>

      <paper-input always-float-label type="number" label="Max examples"
                   placeholder="[[maxExamples]]" value="{{maxExamples}}">
      </paper-input>

      <div class="input-and-tooltip">
          <paper-input always-float-label label="Label vocab path (optional)"
                       placeholder="[[labelVocabPath]]"
                       value="{{labelVocabPath}}"
                       class="label-vocab-path-input"
                       disabled="[[shouldDisableVocabInput_(modelType)]]">
          </paper-input>
          <paper-icon-button icon="help" class="help-icon"></paper-icon-button>
          <paper-tooltip class="tooltip" animation-delay="0" position="right" offset="0">
            An optional text file for use with the results of a classification model.
            Classification models return predicted classes as indices. If a vocab file is
            provided, each predicted class index will be mapped to a label from this file for use
            in the display. Each line in the file corresponds to a label, with the first line
            corresponding to class index 0.
          </paper-tooltip>
        </div>
        <paper-button on-click="getExamplesAndCloseSettings_" class="button"
                      disabled="[[shouldDisableGetExamplesButton_(examplesPath, maxExamples)]]">
          OK
        </paper-button>

    </paper-dialog>
    <div class="dashboard-layout">
      <div class="center">
        <facets-dive id="dive" data="[[visdata]]"
                    on-selected-indices-changed="selectedIndicesChanged_"
                    on-stats-changed="statsChanged_">
        </facets-dive>
        <div id="noexamples" class="noexamples info-text">
          Examples and their inference results will be displayed here.
        </div>
        <paper-spinner-lite id="spinner" hidden active></paper-spinner-lite>
      </div>
      <div class="side-holder">
        <div class="side-content">
          <paper-tabs selected="{{sideTabSelected}}">
            <paper-tab>Datapoint</paper-tab>
            <paper-tab>Configuration</paper-tab>
          </paper-tabs>
          <iron-pages class="side-tabs" selected="{{sideTabSelected}}">
            <div class="datapoint-tab">
              <template is="dom-if" if="[[shouldShowExample_(selectedExampleAndInference)]]">
                <vz-example-viewer class="example-holder" json="{{selectedExampleAndInference.example}}"
                                    on-example-change="exampleChange_" id$="[[getViewerId_()]]">
                </vz-example-viewer>
                <div class="inference-header">Inference Results</div>
                <tf-inference-viewer class="inference-holder" inferences="[[selectedExampleAndInference.inferences]]"
                                      id$="[[getInferenceHolderId_()]]" model-type="[[modelType]]">
                </tf-inference-viewer>
              </template>
              <template is="dom-if" if="[[!shouldShowExample_(selectedExampleAndInference)]]">
                <div class="info-text">Select a datapoint to see its details and inference results here.</div>
                <div class="info-text">Datapoints can be edited and rerun through the model.</div>
              </template>
            </div>
            <div class="config-tab">
              <template is="dom-if" if="[[shouldShowLabelDropdown_(modelType, stats)]]">
                <paper-dropdown-menu label="Set true label feature" class="threshold-dropdown">
                  <paper-listbox class="dropdown-content" selected="{{selectedLabelFeature}}" attr-for-selected="name">
                    <template is="dom-repeat" items="[[getFeatureList_(stats)]]">
                      <paper-item name="[[item]]">[[getFeatureName_(item)]]</paper-item>
                    </template>
                  </paper-listbox>
                </paper-dropdown-menu>
              </template>
              <template is="dom-if" if="[[isClassification_(modelType)]]">
                <template  is="dom-if" if="[[shouldShowOverallTresholder_(selectedThresholdFeature)]]">
                  <div>
                    <paper-input value="Threshold for positive label" readonly=true class="slider-label"
                                  no-label-float=true>
                    </paper-input>
                    <paper-slider class="slider" editable=true min="0" max="1" step="0.01"
                                  immediate-value="{{overallThreshold}}" value="[[overallThreshold]]">
                    </paper-slider>
                  </div>
                  <template is="dom-if" if="[[shouldShowOverallPrChart_(selectedLabelFeature, selectedThresholdFeature, inferences)]]">
                    <div>
                      <vz-line-chart id="prchart" class="pr-line-chart"></vz-line-chart>
                    </div>
                    <tf-confusion-matrix counts="[[getConfusionCounts(classificationStats_, overallThreshold)]]"
                                         class="conf-matrix">
                    </tf-confusion-matrix>
                  </template>
                </template>
                <template is="dom-if" if="[[shouldShowFeatureDropdown_(modelType, stats)]]">
                  <paper-dropdown-menu label="Set positive label thresholds by feature values" class="threshold-dropdown">
                    <paper-listbox class="dropdown-content" selected="{{selectedThresholdFeature}}" attr-for-selected="name">
                      <template is="dom-repeat" items="[[getFeatureList_(stats)]]">
                        <paper-item name="[[item]]">[[getFeatureName_(item)]]</paper-item>
                      </template>
                    </paper-listbox>
                  </paper-dropdown-menu>
                  <template is="dom-repeat" items="[[featureValueThresholds]]">
                    <div>
                      <paper-input value="[[getPrintableValue_(item.value)]]" readonly=true
                                    class="slider-label" no-label-float=true>
                      </paper-input>
                      <paper-slider class="slider" editable=true min="0" max="1" step="0.01"
                                    immediate-value="{{item.threshold}}" value="[[item.threshold]]"
                                    on-value-changed="refreshInferencesNoRegen_">
                      </paper-slider>
                      <template is="dom-if" if="[[shouldShowFeaturePrCharts_(selectedLabelFeature, selectedThresholdFeature, inferences)]]">
                        <div>
                          <vz-line-chart id="[[getPrChartId(index)]]" class="pr-line-chart"></vz-line-chart>
                        </div>
                        <tf-confusion-matrix counts="[[getConfusionCounts(classificationStats_, item.threshold, item.value)]]"
                                            class="conf-matrix">
                        </tf-confusion-matrix>
                      </template>
                    </div>
                  </template>
                </template>
            </div>
          </iron-pages>
        </div>
        <div class="bottom-side">
          <paper-button on-click="inferClicked_" class="button"
                        disabled="[[shouldDisableInferButton_(examplesAndInferences, modelName, inferenceAddress, updatedExample)]]">
            Re-run inference
          </paper-button>
          <paper-icon-button icon="settings" on-click="settingsClicked_"></paper-icon-button>
        </div>
      </div>
    </div>

    <style include="dashboard-style"></style>
  </template>

  <script>
    "use strict";

    const defaultMaxExamples = '1000';
    const defaultLabelVocabPath = '';
    const maxStringLengthToDecode = 100000;
    const inferenceLabelStr = 'inference label';
    const inferenceValueStr = 'inference value';

    Polymer({
      is: "tf-interactive-inference-dashboard",
      properties: {

        // TensorBoard plugin standard.
        requestManager: {
          type: Object,
          value: () => new tf_backend.RequestManager(),
        },
        _canceller: {
          type: Object,
          value: () => new tf_backend.Canceller(),
        },

        // Fields for interactive inference plugin.
        examplesPath: {
          type: String,
        },
        modelName: {
          type: String,
        },
        inferenceAddress: {
          type: String,
        },
        modelType: {
          type: String,
        },
        maxExamples: {
          type: Number,
          value: tf_storage.getStringInitializer('maxExamples',
                                                 {defaultValue: String(defaultMaxExamples)}),
          observer: 'maxExamplesChanged_',
        },
        labelVocabPath: {
          type: String,
          value: tf_storage.getStringInitializer('labelVocabPath',
                                                 {defaultValue: defaultLabelVocabPath}),
          observer: 'labelVocabPathChanged_',
        },
        inferences: {
          type: Object,
          observer: 'newInferences_',
          value: {}
        },
        examplesAndInferences : {
          type: Array,
          value: [],
          observer: 'computeSelectedExampleAndInference',
        },
        selectedExampleAndInference : {
          type: Object,
        },
        visdata: {
          type: Array,
          value: []
        },
        selected: {
          type: Array,
          value: [],
          observer: 'computeSelectedExampleAndInference',
        },
        labelVocab: {
          type: Array,
          value: []
        },
        updatedExample: {
          type: Boolean,
          value: false,
        },
        imageFeatureName: {
          type: String,
          value: 'image/encoded',
          readonly: true,
        },
        // The dataset stats from Facets Dive to be used for the classification threshold logic.
        stats: Object,
        // Feature to set different classification thredholds for the values of
        selectedThresholdFeature: {
          type: String,
          value: '',
          observer: 'thresholdFeatureSelected_',
        },
        // Feature to set different classification thredholds for the values of
        selectedLabelFeature: {
          type: String,
          value: '',
          observer: 'labelFeatureSelected_',
        },
        classificationStats_: {
          type: Object,
          value: {},
        },
        // Array of feature values and their set classification thresholds, for Polymer display
        // purposes.
        featureValueThresholds: Array,
        // A map of feature name to the featureValueThresholds items, for quick lookup.
        featureValueThresholdsMap: Object,
        // The default inference label when the classification threshold isn't met.
        defaultInferenceLabel: {
          type: Number,
          value: 0,
          observer: 'refreshInferences_',
        },
        // The classification threshold when it isn't being set on a per-feature-value basis.
        overallThreshold: {
          type: Number,
          value: 0.5,
          observer: 'refreshInferencesNoRegen_',
        },
        sideTabSelected: {
          type: Number,
          value: 0,
        },
      },

      // Required function.
      reload: function(){
      },

      settingsClicked_: function() {
        this.$.inferencesettings.toggle();
      },

      selectedIndicesChanged_: function(event) {
        this.selected = event.detail.value;
      },

      statsChanged_: function(event) {
        this.stats = event.detail.value;
      },

      isClassification_: function(modelType) {
        return modelType == 'classification';
      },

      shouldShowFeatureDropdown_: function(modelType, stats) {
        return this.isClassification_(modelType) && stats && Object.keys(stats).length > 0;
      },

      shouldShowLabelDropdown_: function(modelType, stats) {
        return modelType == 'classification' && stats && Object.keys(stats).length > 0;
      },

      shouldShowOverallPrChart_: function(selectedLabelFeature, selectedThresholdFeature, inferences) {
        return selectedLabelFeature != '' && selectedThresholdFeature == '' && inferences != null;
      },

      shouldShowFeaturePrCharts_: function(selectedLabelFeature, selectedThresholdFeature, inferences) {
        return selectedLabelFeature != '' && selectedThresholdFeature != '' && inferences != null;
      },

      shouldShowExample_: function(selected) {
        return selected != null;
      },

      getFeatureList_: function(stats) {
        // Do not also threshold settings by the results of the inference as they aren't real data
        // features.
        const features = Object.keys(stats).filter(function(feature) {
          return feature !== inferenceValueStr && feature !== inferenceLabelStr;
        });
        // Add a blank feature to be used for clearing the selected feature.
        features.push('');
        return features;
      },

      thresholdFeatureSelected_: function(feature) {
        const thresholds = [];
        const thresholdsMap = {};
        if (feature.length !== 0) {
          // For the selected feature, set up a dict of each feature value in the dataset to
          // the threshold, defaulting to 0.5. Add this to a list (for display purposes) and create
          // a map of feature value to entry in that list.
          for(var key in this.stats[feature].valueHash) {
            if(this.stats[feature].valueHash.hasOwnProperty(key)) {
              const featureValue = this.stats[feature].valueHash[key].value;
              const thresh = {value: featureValue, threshold: 0.5};
              thresholds.push(thresh);
              thresholdsMap[featureValue] = thresh;
            }
          }
          if (this.stats[feature].totalCount !=
              this.examplesAndInferences.length) {
            // Add an entry for if the example has no feature value for this
            // selected feature.
            const missingValueThresh = {value: undefined, threshold: 0.5};
            thresholds.push(missingValueThresh);
            thresholdsMap[undefined] = missingValueThresh;
          }
        }

        this.featureValueThresholds = thresholds;
        this.featureValueThresholdsMap = thresholdsMap;
        this.refreshInferences_();
      },

      labelFeatureSelected_: function(feature) {
        requestAnimationFrame(() => this.updateClassificationStats_(true));
      },

      updateClassificationStats_: function(regenClassificationStats) {
        if (!this.classificationStats_ || !this.visdata || this.selectedLabelFeature == '') {
          return;
        }
        if (regenClassificationStats) {
          let classificationStats = {};
          classificationStats.thresholds = [];
          for (let i = 0; i < 101; i++) {
            classificationStats.thresholds.push(
              {'TP': 0, 'FP': 0, 'FN': 0, 'TN': 0});
          }
          classificationStats.faceted = {};
          for (let i = 0; i < this.examplesAndInferences.length; i++) {
            const item = this.visdata[i];
            let facetedStats = null;
            if (this.selectedThresholdFeature != '') {
              facetedStats = classificationStats.faceted[
                item[this.selectedThresholdFeature]];
              if (!facetedStats) {
                classificationStats.faceted[
                  item[this.selectedThresholdFeature]] = []
                for (let i = 0; i < 101; i++) {
                  classificationStats.faceted[
                    item[this.selectedThresholdFeature]].push(
                      {'TP': 0, 'FP': 0, 'FN': 0, 'TN': 0});
                }
                facetedStats = classificationStats.faceted[
                  item[this.selectedThresholdFeature]];
              }
            }
            const nonZeroClassification = this.getClassificationBestNonZero(i);
            let thresh = 0;
            for (; thresh <= 100; thresh++) {
              if (thresh > nonZeroClassification.score * 100) {
                break;
              }
              if (+item[this.selectedLabelFeature] ==
                  +nonZeroClassification.label) {
                classificationStats.thresholds[thresh]['TP'] += 1;
                if (facetedStats) {
                  facetedStats[thresh]['TP'] += 1;
                }
              } else {
                classificationStats.thresholds[thresh]['FP'] += 1;
                if (facetedStats) {
                  facetedStats[thresh]['FP'] += 1;
                }
              }
            }
            for (; thresh <= 100; thresh++) {
              if (+item[this.selectedLabelFeature] == 0) {
                classificationStats.thresholds[thresh]['TN'] += 1;
                if (facetedStats) {
                  facetedStats[thresh]['TN'] += 1;
                }
              } else {
                classificationStats.thresholds[thresh]['FN'] += 1;
                if (facetedStats) {
                  facetedStats[thresh]['FN'] += 1;
                }
              }
            }
          }
          this.calcThresholdStats(classificationStats.thresholds);
          for(let key in classificationStats.faceted) {
            if (classificationStats.faceted.hasOwnProperty(key)) {
              this.calcThresholdStats(classificationStats.faceted[key]);
            }
          }

          this.classificationStats_ = classificationStats;
        }
        this.plotPr(
          this.$$('#prchart'), this.classificationStats_.thresholds,
          this.overallThreshold, regenClassificationStats);

        for (let i = 0; i < this.featureValueThresholds.length; i++) {
          this.plotPr(
            this.$$('#' + this.getPrChartId(i)),
            this.classificationStats_.faceted[
              this.featureValueThresholds[i].value],
            this.featureValueThresholds[i].threshold,
            regenClassificationStats);
        }
      },

      plotPr: function(chart, thresholdStats, threshold,
                       regenClassificationStats) {
        if (!thresholdStats || !chart) {
          return;
        }

        let currentThresholdData = null;
        let self = this;
        const data = thresholdStats.map((thresh, i) => {
          if (i - threshold * 100 < 0.5) {
            currentThresholdData = {
              'step': thresh['FPR'],
              'scalar': thresh['TPR'],
              'threshold': i / 100
            };
          }
          return {
            'step': thresh['FPR'],
            'scalar': thresh['TPR'],
            'threshold': i / 100
          };
        }).reverse();
        if (regenClassificationStats) {
          chart.setVisibleSeries(['ROC', 'Threshold set']);
          chart.setSeriesData('ROC', data);
          const valueFormatter = d3.format('.2f');
          chart.xAxisFormatter = d3.format('.2f');
          const percentageFormatter = d3.format(",.1%");
          chart.tooltipColumns = [
            {
                title: 'Threshold',
                evaluate: function (d) {
                  return valueFormatter(d.datum.threshold);
                },
            },
            {
                title: 'TPR',
                evaluate: function (d) {
                  return percentageFormatter(d.datum.scalar);
                },
            },
            {
                title: 'FPR',
                evaluate: function (d) {
                  return percentageFormatter(d.datum.step);
                },
            },
          ];
        }
        chart.setSeriesData('Threshold set', [currentThresholdData]);
      },

      calcThresholdStats: function(stats) {
        for (let i = 0; i < stats.length; i++) {
          stats[i]['TPR'] = stats[i]['TP'] / (stats[i]['TP'] + stats[i]['FN']);
          stats[i]['FPR'] = stats[i]['FP'] / (stats[i]['FP'] + stats[i]['TN']);
        }
      },

      getClassificationBestNonZero: function(index) {
        // Find the first inference label in the score-sorted list that is non-zero.
        let indexForNonZeroLabel = 0;
        const inferenceIndex = this.examplesAndInferences[index].inferences.length - 1;
        for (let i = 0; i < this.examplesAndInferences[index].inferences[inferenceIndex].length; i++) {
          if (+this.examplesAndInferences[index].inferences[inferenceIndex][i].label !== 0) {
            indexForNonZeroLabel = i;
            break;
          }
        }

        return this.examplesAndInferences[index].inferences[inferenceIndex][indexForNonZeroLabel];
      },


      getConfusionCounts(classificationStats, threshold, featureValue) {
        return {
          'tp': this.getConfMatrixValue(classificationStats, threshold, 'TP', featureValue),
          'fp': this.getConfMatrixValue(classificationStats, threshold, 'FP', featureValue),
          'tn': this.getConfMatrixValue(classificationStats, threshold, 'TN', featureValue),
          'fn': this.getConfMatrixValue(classificationStats, threshold, 'FN', featureValue),
        }
      },

      getConfMatrixValue: function(classificationStats, threshold, stat, featureValue) {
        const index = Math.floor(threshold * 100)
        if (!classificationStats.thresholds) {
          return 0;
        }
        if (featureValue == null) {
          return classificationStats.thresholds[index][stat];
        }
        if (classificationStats.faceted[featureValue] == null) {
          return 0;
        }
        return classificationStats.faceted[featureValue][index][stat];
      },

      getPrChartId: function(index) {
        return 'prchart' + index;
      },

      getPrintableValue_: function(value) {
        if (!value && value !== 0) {
          return '<feature value missing>';
        }
        return value;
      },

      getFeatureName_: function(feature) {
        // If feature name is blank then this represents selecting no feature.
        if (feature.length === 0) {
          return '<none>';
        }
        return feature;
      },

      shouldShowOverallTresholder_: function(feature) {
        return feature.length === 0;
      },

      maxExamplesChanged_: tf_storage.getStringObserver(
          'maxExamples', {defaultValue: defaultMaxExamples}),

      labelVocabPathChanged_: tf_storage.getStringObserver(
          'labelVocabPath', {defaultValue: defaultLabelVocabPath}),

      computeSelectedExampleAndInference: function() {
        if (!this.selected || !this.examplesAndInferences) {
          this.selectedExampleAndInference = null;
          return;
        }
        // Set the exampleIndex so that the mutant inference plugin shows the example selected
        // by the user.
        if (this.selected.length > 0) {
          tf_storage.setNumber('exampleIndex', this.selected[0]);
        }
        const self = this;
        const selectedItems = this.examplesAndInferences.filter(function(item, index) {
          return self.selected.includes(index);
        });
        this.selectedExampleAndInference = selectedItems.length > 0 ? selectedItems[0] : null;
      },

      shouldDisableGetExamplesButton_: function(examplesPath) {
        return examplesPath.length == 0;
      },

      shouldDisableInferButton_: function(examples, modelName, inferenceAddress, updatedExample) {
        return examples.length == 0 || modelName.length == 0 || inferenceAddress.length == 0 ||
          !updatedExample;
      },

      shouldDisableVocabInput_: function(modelType) {
        return modelType == 'regression';
      },

      newInferences_: function() {
        this.updateInferences_(true);
      },

      refreshInferencesNoRegen_: function() {
        this.refreshInferences_(true);
      },

      refreshInferences_: function(noRegen) {
        this.updateInferences_(false);
        requestAnimationFrame(() => this.updateClassificationStats_(!noRegen));
      },

      updateInferences_: function(newInferencesCalculated) {
        if (!this.examplesAndInferences || !this.inferences.indices ||
            this.inferences.indices.length == 0) {
          return;
        }
        const inferenceMap = {}
        const isClassification = !!this.inferences.results.classification;
        for (let i = 0; i < this.inferences.indices.length; i++) {
          inferenceMap[this.inferences.indices[i]] = isClassification ?
              this.inferences.results.classification.classifications[i].classes.sort(function(a, b) {
                return b.score - a.score;
              }) :
              [{label: '', score: this.inferences.results.regression.regressions[i].value}];
        }
        this.set('examplesAndInferences', this.examplesAndInferences.map(
          function(item, index) {
            let inferences = item.inferences ? item.inferences : [];
            if (inferenceMap[index] && newInferencesCalculated) {
              inferences = inferences.concat([inferenceMap[index]]);
            }
            return {example: item.example, inferences: inferences};
          }));
        const self = this;
        let hasInferenceLabels = false;
        this.visdata.forEach(function(item, index) {
          if (isClassification) {
            self.setItemInferenceValue(item, index, self.selectedThresholdFeature);
          } else {
            item[inferenceValueStr] = self.examplesAndInferences[index].inferences[0].value;
          }


          if (isClassification && self.labelVocab.length > 0) {
            for (let labelIndex = 0;
                 labelIndex < self.examplesAndInferences[index].inferences[0].length; labelIndex++) {
              self.examplesAndInferences[index].inference[labelIndex].vocabLabel =
                self.labelVocab[self.examplesAndInferences[index].inferences[0][labelIndex].label];
            }
            item[inferenceLabelStr] = self.labelVocab[item[inferenceValueStr]];
            hasInferenceLabels = true;
          }
        });
        this.refreshDive_();
        if (newInferencesCalculated) {
          this.$.dive.colorBy = hasInferenceLabels ? inferenceLabelStr : inferenceValueStr;
        }
        this.updatedExample = false;
      },

      setItemInferenceValue: function(item, index, feature) {
        let threshold = this.overallThreshold;
        // If a feature has been selected (string will be non-empty in this case), then get the
        // appropriate threshold for this item's value for that feature. Otherwise the overall
        // threshold will be used.
        if (feature.length !== 0) {
          const featureValue = item[feature];
          threshold = this.featureValueThresholdsMap[featureValue].threshold;
        }

        // Find the first inference label in the score-sorted list that is non-zero.
        let indexForNonZeroLabel = 0;
        for (let i = 0; i < this.examplesAndInferences[index].inferences[0].length; i++) {
          if (+this.examplesAndInferences[index].inferences[0][i].label !== 0) {
            indexForNonZeroLabel = i;
            break;
          }
        }

        if (this.examplesAndInferences[index].inferences[0][indexForNonZeroLabel].score >= threshold) {
          item[inferenceValueStr] =
            this.examplesAndInferences[index].inferences[0][indexForNonZeroLabel].label;
        } else {
          item[inferenceValueStr] = this.defaultInferenceLabel.toString();
        }
      },

      inferClicked_: function() {
        var url = this.makeUrl_('/data/plugin/interactiveinference/infer',
                                {'inference_address': this.inferenceAddress,
                                 'model_name': this.modelName,
                                 'model_type': this.modelType,
                                 'label_vocab_path': this.labelVocabPath});
        const inferContents = result => {
          this.$.spinner.hidden = true;
          this.labelVocab = /** @type {!Array} */ (JSON.parse(result.value.vocab));
          this.inferences = /** @type {!Object} */ (JSON.parse(result.value.inferences));
        };
        this.makeAsyncRequest_(url, inferContents);
        this.$.spinner.hidden = false;
      },

      exampleChange_: function(event) {
        var id = 0;
        var index = this.selected.length == 0 ? id : this.selected[id];
        this.updateExample_(JSON.stringify(event.target.json), index);
        const inferenceViewerIdStr = '#' + this.getInferenceHolderId_(id);
        const inferenceViewer = this.$$(inferenceViewerIdStr);
        inferenceViewer.inference = null;
        this.visdata[index] = this.exampleToDataPoint_(event.target.json);
        this.refreshDive_();
        this.updatedExample = true;
      },

      refreshDive_: function() {
        const temp = this.visdata;
        this.visdata = [];
        this.visdata = temp;
        const tempSelected = this.$.dive.selectedData;
        this.$.dive.selectedData = [];
        this.$.dive.selectedData = tempSelected;
      },

      updateExample_: function(exampleJson, index){
        var url = this.makeUrl_('/data/plugin/interactiveinference/update_example',
                                {'example': exampleJson,
                                 'index': index});

        this.makeAsyncRequest_(url, null);
      },

      getViewerId_: function() {
        return 'viewer_';
      },

      getInferenceHolderId_: function() {
        return 'inference_';
      },

      makeUrl_: function(prefix, paramsDict){
        return prefix + '?' + Object.keys(paramsDict).map(
          k => k + '=' + encodeURIComponent(paramsDict[k])).join('&');
      },

      showToast_: function(msg) {
        var toast = document.createElement('paper-toast');
        document.body.appendChild(toast);
        toast.text = msg;
        toast.show();

        // Also, log to console.
        console.error(msg);
      },

      makeAsyncRequest_: function(url, thenDoFn){
        var self = this;
        const wrapperFn = this._canceller.cancellable(function(result){
          if (result.cancelled) {
            return;
          }
          if (result.value && result.value.error){
            // show toast with the error
            self.showToast_(result.value.error);
            self.$.spinner.hidden = true;
          } else if (thenDoFn) {
            thenDoFn(result);
          }
        });
        this.requestManager.request(url).then(wrapperFn);
      },

      exampleToDataPoint_: function(example) {
        const d = {};
        const features = Object.keys(example.features.feature)
        for (const index in features) {
          const fname = features[+index];
          // Ignore encoded image feature when creating data for Facets Dive.
          if (fname == this.imageFeatureName) {
            continue;
          }
          let v = null;
          if (example.features.feature[fname].int64List) {
            v = example.features.feature[fname].int64List.value;
          } else if (example.features.feature[fname].floatList) {
            v = example.features.feature[fname].floatList.value;
          } else if (example.features.feature[fname].bytesList &&
                     example.features.feature[fname].bytesList.value) {
            v = example.features.feature[fname].bytesList.value.map(val => {
              // Strings above a max length are most likely binary encoded data and not strings
              // and therefore shouldn't be decoded for display in Facets Dive.
              if (val.length > maxStringLengthToDecode) {
                return 'ERROR: string not decoded due to length';
              }
              try {
                return atob(val);
              } catch (err) {
                console.error('Error decoding string: ' + err);
                return 'ERROR: error decoding string';
              }
            });
          }
          if (v) {
            if (v.length == 1) {
              v = v[0];
              if (!isNaN(v)) {
                v = Number(v);
              }
            }
            d[fname] = v;
          }
        }
        return d;
      },

      getExamplesAndCloseSettings_: function() {
        this.settingsClicked_();
        this.getExamples_();
      },

      getExamples_: function(){
        var url = this.makeUrl_('/data/plugin/interactiveinference/examples_from_path',
                                {'examples_path': this.examplesPath,
                                 'max_examples': this.maxExamples});

        const updateExampleContents = result => {
          this.$.noexamples.style.display = 'none';
          this.$.spinner.hidden = true;
          this.examplesAndInferences = result.value.examples.map(function(ex) {
            return {example: JSON.parse(ex)};});
          this.updatedExample = true;
          const self = this;
          this.visdata = this.examplesAndInferences.map(function(ex) {
            return self.exampleToDataPoint_(ex.example);
          });
          this.$.dive.atlasUrl = '';
          if (result.value.sprite) {
            this.$.dive.atlasUrl = this.makeUrl_('/data/plugin/interactiveinference/sprite', {});
          }
          if (!this.shouldDisableInferButton_(
              this.examplesAndInferences, this.modelName, this.inferenceAddress,
              this.updatedExample)) {
            this.inferClicked_();
          }
        };
        this.makeAsyncRequest_(url, updateExampleContents);
        this.$.spinner.hidden = false;
      },
    });

    tf_tensorboard.registerDashboard({
      plugin: 'interactiveinference',
      elementName: 'tf-interactive-inference-dashboard',
      tabName: 'Interactive Inference',
    });

  </script>
</dom-module>

