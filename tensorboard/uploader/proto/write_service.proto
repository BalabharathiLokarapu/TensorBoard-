syntax = "proto3";

package tensorboard.service;

import "tensorboard/uploader/proto/scalar.proto";
import "tensorboard/compat/proto/summary.proto";

// Service for writing data to TensorBoard.dev.
service TensorBoardWriterService {
  // Request for a new location to write TensorBoard readable events.
  rpc CreateExperiment(CreateExperimentRequest)
      returns (CreateExperimentResponse) {}
  // Request that an experiment be deleted, along with all tags and scalars
  // that it contains. This call may only be made by the original owner of the
  // experiment.
  rpc DeleteExperiment(DeleteExperimentRequest)
      returns (DeleteExperimentResponse) {}
  // Request that unreachable data be purged. Used only for testing;
  // disabled in production.
  rpc PurgeData(PurgeDataRequest) returns (PurgeDataResponse) {}
  // Request that scalar data be stored in TensorBoard.dev.
  rpc WriteScalar(WriteScalarRequest) returns (WriteScalarResponse) {}
  // Request that blob data be stored in TensorBoard.dev.
  rpc WriteBlob(stream WriteBlobRequest) returns (stream WriteBlobResponse) {}
  // Request that the calling user and all their data be permanently deleted.
  // Used for testing purposes.
  rpc DeleteOwnUser(DeleteOwnUserRequest) returns (DeleteOwnUserResponse) {}
}

// This is currently empty on purpose.  No information is necessary
// to request a URL, except. authorization of course, which doesn't
// come within the proto.
message CreateExperimentRequest {
  // This is empty on purpose.
}

// Carries all information necessary to:
//  1. Inform the user where to navigate to see their TensorBoard.
//  2. Subsequently load (Scalars, Tensors, etc.) to the specified location.
message CreateExperimentResponse {
  // Service-wide unique identifier of an uploaded log dir.
  // eg: "1r9d0kQkh2laODSZcQXWP"
  string experiment_id = 1;
  // Url the user should navigate to to see their TensorBoard
  // eg: "https://example.com/public/1r9d0kQkh2laODSZcQXWP"
  string url = 2;
}

message DeleteExperimentRequest {
  // Service-wide unique identifier of an uploaded log dir.
  // eg: "1r9d0kQkh2laODSZcQXWP"
  string experiment_id = 1;
}

message DeleteExperimentResponse {
  // This is empty on purpose.
}

// Only used for testing; corresponding RPC is disabled in prod.
message PurgeDataRequest {
  // Maximum number of entities of a given kind to purge at once (e.g.,
  // maximum number of tags to purge). Required; must be positive.
  int32 batch_limit = 1;
}

// Only used for testing; corresponding RPC is disabled in prod.
message PurgeDataResponse {
  // Stats about how many elements where purged. Compare to the batch
  // limit specified in the request to estimate whether the backlog has
  // any more items.
  PurgeStats purge_stats = 1;
}

// Details about what actions were taken as a result of a purge request.
// These values are upper bounds; they may exceed the true values.
message PurgeStats {
  // Number of tags deleted as a result of this request.
  int32 tags = 1;
  // Number of experiments marked as purged as a result of this request.
  int32 experiments = 2;
  // Number of users deleted as a result of this request.
  int32 users = 3;
}

// Carries all that is needed to add additional run data to the hosted service.
message WriteScalarRequest {
  // All the data to store for one Run.  This data will be stored under the
  // corresponding run in the hosted storage. WriteScalarRequest is merged into
  // the data store for the keyed run. The tags and included scalars will be
  // the union of the data sent across all WriteScalarRequests. Metadata by
  // default uses a 'first write wins' approach.
  message Run {
    // The name of this run.  For example "/some/path/mnist_experiments/run1/"
    string name = 1;
    // Data to store for this Run/Tag combination.
    repeated Tag tags = 2;
  }

  // All the data to store for one Tag of one Run.  This data will be stored
  // under the corresponding run/tag in the hosted storage. A tag corresponds to
  // a single time series.
  message Tag {
    // The name of this tag.  For example "loss"
    string name = 1;
    // Data to store for this Run/Tag combination.
    repeated ScalarPoint points = 2;
    // The metadata of this tag.
    .tensorboard.SummaryMetadata metadata = 3;
  }

  // Which experiment to write to - corresponding to one hosted TensorBoard URL.
  // The requester must have authorization to write to this location.
  string experiment_id = 1;
  // Data to append to the existing storage at the experiment_id.
  repeated Run runs = 2;
}

// Everything the caller needs to know about how the writing went.
// (Currently empty)
message WriteScalarResponse {
  // This is empty on purpose.
}

// The blob writing procedure works as follows:
//  * The caller instantiates a WriteBlob RPC, which is a bidirectional stream.
//  * The caller sends a number of WriteBlobRequests, providing the blob data
//    in an ordered sequence of chunks.
//  * The request size should be less than 4 MiB (2^20 = 4,194,304), because
//    that is the default request limit for gRPC.  Accounting for the other
//    fields of the request, then, and leaving some padding for safety, the data
//    chunk should be somewhat smaller-- perhaps simply 4e6 bytes.
//  * The first of these requests must provide write_blob_first_request_data,
//    and the subsequent ones must not.
//  * The last of these requests must set finalize_object=True, and the prior
//    ones must not.
//  * For a blob <= 4MB, a single chunk suffices, so the single request is both
//    the first and the last.
//  * The caller receives a sequence of WriteBlobResponses in return.  Each
//    WriteBlobResponse corresponds to one WriteBlobRequest in order, reporting
//    the state of the write operation.
//  * The caller may choose to verify each response before sending the next
//    request, or it may continue sending requests optimistically.
//
// Note that the WriteBlobRequest does not mirror the nested structure of
// WriteScalarRequest, because we only ever send one blob at a time.

// Metadata included with only the first chunk of the blob write stream.
message WriteBlobFirstRequestData {
  string experiment_id = 1;
  string run = 2;
  string tag = 3;
  int64 step = 4;
  int64 index = 5;
  // Note that metadata.plugin_data.content does not carry the payload.
  .tensorboard.SummaryMetadata metadata = 6;
}

// A single chunk of the blob write stream.
message WriteBlobRequest {
  WriteBlobFirstRequestData write_blob_first_request_data = 1;
  bytes data = 2 [ctype = CORD];
  // The position in the blob where this chunk begins.
  // This must equal the sum of the sizes of the chunks sent so far.
  int64 offset = 3;
  // CRC32C of current data buffer. While optional it is recommended that
  // clients include the crc32c for every data buffer, to protect against data
  // corruption. Note that for multi-shot writes, specifying the crc32c for
  // every data buffer provides stronger protection than just providing
  // the final_crc32c at the end of the upload.
  fixed32 crc32c = 4;
  // Indicates that this is the last chunk of the stream.
  bool finalize_object = 5;
  // CRC32C of the entire blob. Optional but recommended, to protect against
  // data corruption. This should be set only when finalize_object=True.
  fixed32 final_crc32 = 6;
}

message WriteBlobResponse {
  enum ObjectState {
    // Object state is unknown. This value should never be used; it is present
    // only as a proto3 best practice.
    // See https://developers.google.com/protocol-buffers/docs/proto3#enum
    UNKNOWN = 0;

    // Object is being written and not yet finalized.
    UNFINALIZED = 1;

    // Object is finalized.
    CURRENT = 2;
  }

  // State of the object (still appending vs. complete).
  ObjectState object_state = 1;
  // Size of the object in bytes.  This is the sum of the chunk sizes
  // received from the stream so far.  In the response to the final chunk,
  // this size should equal the total size of the blob.
  int64 size = 2;
}

// Requests that the calling user and all their data be permanently deleted.
message DeleteOwnUserRequest {
  // This is empty on purpose.
}

// Everything the caller needs to know about how the deletion went.
message DeleteOwnUserResponse {
  // This is empty on purpose.
}
