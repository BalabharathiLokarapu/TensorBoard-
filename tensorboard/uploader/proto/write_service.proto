syntax = "proto3";

package tensorboard.service;

import "tensorboard/uploader/proto/scalar.proto";
import "tensorboard/compat/proto/summary.proto";

// Service for writing data to TensorBoard.dev.
service TensorBoardWriterService {
  // Request for a new location to write TensorBoard readable events.
  rpc CreateExperiment(CreateExperimentRequest)
      returns (CreateExperimentResponse) {}
  // Request that an experiment be deleted, along with all tags and scalars
  // that it contains. This call may only be made by the original owner of the
  // experiment.
  rpc DeleteExperiment(DeleteExperimentRequest)
      returns (DeleteExperimentResponse) {}
  // Request that unreachable data be purged. Used only for testing;
  // disabled in production.
  rpc PurgeData(PurgeDataRequest) returns (PurgeDataResponse) {}
  // Request that scalar data be stored in TensorBoard.dev.
  rpc WriteScalar(WriteScalarRequest) returns (WriteScalarResponse) {}
  // Request that blob data be stored in TensorBoard.dev.
  rpc CreateBlobSequence(CreateBlobSequenceRequest) returns (CreateBlobSequenceResponse) {}
  rpc WriteBlob(stream WriteBlobRequest) returns (stream WriteBlobResponse) {}
  // Request that the calling user and all their data be permanently deleted.
  // Used for testing purposes.
  rpc DeleteOwnUser(DeleteOwnUserRequest) returns (DeleteOwnUserResponse) {}
}

// This is currently empty on purpose.  No information is necessary
// to request a URL, except. authorization of course, which doesn't
// come within the proto.
message CreateExperimentRequest {
  // This is empty on purpose.
}

// Carries all information necessary to:
//  1. Inform the user where to navigate to see their TensorBoard.
//  2. Subsequently load (Scalars, Tensors, etc.) to the specified location.
message CreateExperimentResponse {
  // Service-wide unique identifier of an uploaded log dir.
  // eg: "1r9d0kQkh2laODSZcQXWP"
  string experiment_id = 1;
  // Url the user should navigate to to see their TensorBoard
  // eg: "https://example.com/public/1r9d0kQkh2laODSZcQXWP"
  string url = 2;
}

message DeleteExperimentRequest {
  // Service-wide unique identifier of an uploaded log dir.
  // eg: "1r9d0kQkh2laODSZcQXWP"
  string experiment_id = 1;
}

message DeleteExperimentResponse {
  // This is empty on purpose.
}

// Only used for testing; corresponding RPC is disabled in prod.
message PurgeDataRequest {
  // Maximum number of entities of a given kind to purge at once (e.g.,
  // maximum number of tags to purge). Required; must be positive.
  int32 batch_limit = 1;
}

// Only used for testing; corresponding RPC is disabled in prod.
message PurgeDataResponse {
  // Stats about how many elements where purged. Compare to the batch
  // limit specified in the request to estimate whether the backlog has
  // any more items.
  PurgeStats purge_stats = 1;
}

// Details about what actions were taken as a result of a purge request.
// These values are upper bounds; they may exceed the true values.
message PurgeStats {
  // Number of tags deleted as a result of this request.
  int32 tags = 1;
  // Number of experiments marked as purged as a result of this request.
  int32 experiments = 2;
  // Number of users deleted as a result of this request.
  int32 users = 3;
}

// Carries all that is needed to add additional run data to the hosted service.
message WriteScalarRequest {
  // All the data to store for one Run.  This data will be stored under the
  // corresponding run in the hosted storage. WriteScalarRequest is merged into
  // the data store for the keyed run. The tags and included scalars will be
  // the union of the data sent across all WriteScalarRequests. Metadata by
  // default uses a 'first write wins' approach.
  message Run {
    // The name of this run.  For example "/some/path/mnist_experiments/run1/"
    string name = 1;
    // Data to store for this Run/Tag combination.
    repeated Tag tags = 2;
  }

  // All the data to store for one Tag of one Run.  This data will be stored
  // under the corresponding run/tag in the hosted storage. A tag corresponds to
  // a single time series.
  message Tag {
    // The name of this tag.  For example "loss"
    string name = 1;
    // Data to store for this Run/Tag combination.
    repeated ScalarPoint points = 2;
    // The metadata of this tag.
    .tensorboard.SummaryMetadata metadata = 3;
  }

  // Which experiment to write to - corresponding to one hosted TensorBoard URL.
  // The requester must have authorization to write to this location.
  string experiment_id = 1;
  // Data to append to the existing storage at the experiment_id.
  repeated Run runs = 2;
}

// Everything the caller needs to know about how the writing went.
// (Currently empty)
message WriteScalarResponse {
  // This is empty on purpose.
}

// The blob sequence writing procedure works as follows:
//  * The caller requests creation of a new BlobSequence, via the
//    CreateBlobSequence RPC. The response provides a new BlobSequence ID.
//  * The caller writes each blob in the sequence separately via the WriteBlob
//    RPC as described below, providing the blob sequence ID and sequence index
//    for each blob.
//  * Multiple WriteBlob streams may operate in parallel, with no constraint
//    on their ordering.

// Blob sequence uploads are resumable, as follows:
//  * The client starts the upload process with a new CreateBlobSequence RPC.
//  * The blob sequences are uniquely keyed by experiment, run, tag, and step.
//    Since this is a second (or later) attempt regarding an existing sequence,
//    a new sequence is not created.  Instead the existing sequence ID is
//    returned.
//  * The client attempts to upload each blob in the sequence.  These uploads
//    resume or may be skipped entirely, as needed, according to the below
//    procedure.

// The blob writing procedure is as follows.  It is intrinsically resumable.
//  * The caller instantiates a WriteBlob RPC, which is a bidirectional stream.
//  * The first of these requests must provide write_blob_first_request_data,
//    and the subsequent ones must not.
//  * The first request should send no actual data; it acts as a request for the
//    current status of the blob, in case it has already been partially or fully
//    uploaded.
//  * The first WriteBlobResponse reports the state, size, and crc32c of the
//    object so far, i.e. taking into account any previously uploaded data.
//  * The client proceeds to upload from the specified offset (optionally
//    validating the crc32c up to that point first).
//  * The caller sends a number of additional WriteBlobRequests, providing the
//    blob data in an ordered sequence of chunks.
//  * The caller receives a sequence of WriteBlobResponses in return.  Each
//    WriteBlobResponse corresponds to one WriteBlobRequest in order, reporting
//    the state of the write operation.
//  * In general, the caller should not wait to verify that each response
//    reports the expected status, size, and crc32c before sending the next
//    request.  Doing so harms throughput, with little benefit since any
//    mismatch on the server side will cause the RPC to throw error anyway.
//  * The request size should be less than 4 MiB (2^20 = 4,194,304), because
//    that is the default request limit for gRPC. Accounting for the other
//    fields of the request, then, and leaving some padding for safety, the data
//    chunk should be somewhat smaller-- perhaps simply 4e6 bytes.
//  * The last of these requests must set finalize_object=True, and the prior
//    ones must not.
//  * For a blob <= 4MB, a single data chunk suffices, so there are two
//    requests: one to learn the status, and one to upload the data.
//
// Note that the WriteBlobRequest does not mirror the nested structure of
// WriteScalarRequest, because we only ever send one blob at a time.

message CreateBlobSequenceRequest {
  string experiment_id = 1;
  string run = 2;
  string tag = 3;
  int64 step = 4;
  int64 final_sequence_length = 5;
}

message CreateBlobSequenceResponse {
  string sequence_id = 1;
}

// Metadata included with only the first chunk of the blob write stream.
message WriteBlobFirstRequestData {
  string sequence_id = 1;
  int64 index = 2;
  // Note that metadata.plugin_data.content does not carry the payload.
  .tensorboard.SummaryMetadata metadata = 3;
}

// A single chunk of the blob write stream.
message WriteBlobRequest {
  WriteBlobFirstRequestData write_blob_first_request_data = 1;
  // The bytes in this chunk.  For the first chunk only, this value should be
  // empty.  This allows determining from the response how much of the blob has
  // already been uploaded, if any, without sending redundant data.
  bytes data = 2 [ctype = CORD];
  // The position in the blob where this chunk begins.
  // This must equal the sum of the sizes of the chunks sent so far (except on
  // the first request).
  int64 offset = 3;
  // CRC32C of current data buffer. Clients must include the crc32c for every
  // data buffer, to protect against data corruption.  Note that for multi-shot
  // writes, specifying the crc32c for every data buffer provides stronger
  // protection than just providing the final_crc32c at the end of the upload.
  fixed32 crc32c = 4;
  // Indicates that this is the last chunk of the stream.
  bool finalize_object = 5;
  // CRC32C of the entire blob.  Required, to protect against data corruption.
  // This should be set only when finalize_object=True.
  fixed32 final_crc32c = 6;
}

message WriteBlobResponse {
  enum ObjectState {
    // Object state is unknown. This value should never be used; it is present
    // only as a proto3 best practice.
    // See https://developers.google.com/protocol-buffers/docs/proto3#enum
    UNKNOWN = 0;

    // Object is being written and not yet finalized.
    UNFINALIZED = 1;

    // Object is finalized.
    CURRENT = 2;
  }

  // State of the object (still appending vs. complete).
  ObjectState object_state = 1;
  // Size of the object in bytes.  This is the sum of the chunk sizes
  // received from the stream so far.  In the response to the final chunk,
  // this size should equal the total size of the blob.
  int64 size = 2;
  // crc32c of the blob data read so far, i.e. over the byte range [0, size].
  // In the response to the final chunk, this value should equal final_crc32.
  fixed32 cumulative_crc32c = 3;
}

// Requests that the calling user and all their data be permanently deleted.
message DeleteOwnUserRequest {
  // This is empty on purpose.
}

// Everything the caller needs to know about how the deletion went.
message DeleteOwnUserResponse {
  // This is empty on purpose.
}
